import { Injectable } from '@nestjs/common';
import { Processor } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { BaseConsumer } from '../services/base-consumer.service';
import { AuditLogService } from '../../logging/audit-log.service';
import { PrismaService } from '../../prisma/prisma.service';
import { QueueConfigService } from '../queue-config.service';
import { QueueEventsService } from '../services/queue-events.service';
import { CircuitBreakerService, Dependency } from '../services/circuit-breaker.service';
import { QuarantineService } from '../services/quarantine.service';
import { JobSlaService } from '../services/job-sla.service';
import { JobType } from '../types/job-envelope';

/**
 * AI Content Consumer
 * M11 - Queue Platform: "AI Jobs Processing"
 *
 * Processes:
 * - Article generation
 * - AI editor tool actions
 * - Content enhancement
 */

@Injectable()
export class AiContentConsumer extends BaseConsumer {
  protected readonly DEFAULT_DEPENDENCIES: Dependency[] = [Dependency.OPENROUTER_API, Dependency.REDIS];

  constructor(
    auditLog: AuditLogService,
    prisma: PrismaService,
    queueConfig: QueueConfigService,
    queueEvents: QueueEventsService,
    circuitBreaker: CircuitBreakerService,
    quarantine: QuarantineService,
    jobSla: JobSlaService,
  ) {
    super(
      JobType.AI_CONTENT,
      auditLog,
      prisma,
      queueConfig,
      queueEvents,
      circuitBreaker,
      quarantine,
      jobSla,
    );
  }

  /**
   * Process AI Content Job
   */
  protected async process(job: Job<any>): Promise<any> {
    const { aiJobId, actorId, tenantId, workspaceId, entity, meta, traceId } = job.data;
    const { prompt, model, temperature, maxTokens, articleId } = meta;

    this.logger.log(`Processing AI Content job: ${aiJobId} (article: ${articleId})`);

    // 1. Validate inputs
    if (!articleId || !prompt) {
      throw new Error('Missing required fields: articleId, prompt');
    }

    // 2. Get article
    const article = await this.prisma.article.findUnique({
      where: { id: articleId },
      include: {
        tenant: true,
        workspace: true,
      },
    });

    if (!article) {
      throw new Error(`Article not found: ${articleId}`);
    }

    // 3. Check tenant/workspace limits (AI usage)
    await this.checkAiUsageLimits(tenantId, workspaceId);

    // 4. Call AI Service (Circuit Breaker protected)
    const aiResponse = await this.callAiService({
      prompt,
      model,
      temperature,
      maxTokens,
    });

    // 5. Process response
    const generatedContent = aiResponse.content || aiResponse.text || aiResponse.choices?.[0]?.message?.content;

    if (!generatedContent) {
      throw new Error('No content generated by AI');
    }

    // 6. Update article with generated content
    const updatedArticle = await this.prisma.article.update({
      where: { id: articleId },
      data: {
        content: generatedContent,
        aiGeneratedAt: new Date(),
      },
    });

    // 7. Record AI usage (cost, tokens)
    await this.recordAiUsage({
      aiJobId,
      tenantId,
      workspaceId,
      actorId,
      model,
      promptTokens: aiResponse.usage?.prompt_tokens,
      completionTokens: aiResponse.usage?.completion_tokens,
      totalTokens: aiResponse.usage?.total_tokens,
      cost: this.calculateCost(aiResponse.usage, model),
    });

    this.logger.log(`AI Content job completed: ${aiJobId} (article: ${articleId})`);

    return {
      success: true,
      article: updatedArticle,
      aiResponse,
    };
  }

  /**
   * Check AI usage limits
   */
  private async checkAiUsageLimits(tenantId: number, workspaceId: number): Promise<void> {
    // Get tenant plan/limits
    const tenant = await this.prisma.tenant.findUnique({
      where: { id: tenantId },
      select: { plan: true, limits: true },
    });

    if (!tenant) {
      throw new Error(`Tenant not found: ${tenantId}`);
    }

    const limits = (tenant.limits as any) || {};
    const monthlyLimit = limits.aiRequests || 10000; // Default 10k

    // Check current month usage from Redis or DB
    const currentMonth = new Date().toISOString().substring(0, 7); // YYYY-MM
    const usageKey = `teknav:ai:usage:${tenantId}:${workspaceId}:${currentMonth}`;
    const currentUsage = await this.prisma.redis?.get(usageKey) || '0';
    const usage = parseInt(currentUsage as string);

    if (usage >= monthlyLimit) {
      throw new Error(`AI usage limit exceeded: ${usage}/${monthlyLimit}`);
    }

    // Increment usage
    await this.prisma.redis?.incr(usageKey);
    await this.prisma.redis?.expire(usageKey, 30 * 24 * 60 * 60); // 30 days TTL
  }

  /**
   * Call AI Service (simulated - would use OpenAI/Azure/etc.)
   */
  private async callAiService(params: {
    prompt: string;
    model: string;
    temperature: number;
    maxTokens: number;
  }): Promise<any> {
    // In production, this would call actual AI service
    // For MVP, we'll simulate a response
    await new Promise(resolve => setTimeout(resolve, 1000)); // 1s delay

    return {
      content: `<h1>${params.prompt}</h1>\n\n<p>This is AI-generated content.</p>`,
      usage: {
        prompt_tokens: Math.ceil(params.prompt.length / 4),
        completion_tokens: Math.ceil(params.maxTokens / 4),
        total_tokens: Math.ceil(params.prompt.length / 4) + Math.ceil(params.maxTokens / 4),
      },
    };
  }

  /**
   * Calculate cost (mock)
   */
  private calculateCost(usage: any, model: string): number {
    // Simulated cost calculation
    const per1k = 0.002; // $0.002 per 1k tokens
    const tokens = usage.total_tokens || 0;
    return (tokens / 1000) * per1k;
  }

  /**
   * Record AI usage
   */
  private async recordAiUsage(params: {
    aiJobId: number;
    tenantId: number;
    workspaceId: number;
    actorId: number;
    model: string;
    promptTokens?: number;
    completionTokens?: number;
    totalTokens?: number;
    cost: number;
  }): Promise<void> {
    await this.prisma.aiJob.update({
      where: { id: params.aiJobId },
      data: {
        cost: params.cost,
      },
    });

    // Also store in separate AiUsage table if exists
    // For MVP, we'll just log to AuditLog
    await this.auditLog.logAction({
      actorUserId: params.actorId,
      action: 'ai.usage.recorded',
      resource: 'AiUsage',
      payload: params,
    });
  }

  /**
   * Get circuit breaker config override
   */
  protected getCircuitBreakerConfig(dep: Dependency) {
    if (dep === Dependency.OPENROUTER_API) {
      return {
        failureThreshold: 10,
        resetTimeout: 120000, // 2 minutes
        halfOpenMaxCalls: 5,
      };
    }
    return {};
  }
}
